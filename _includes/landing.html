<!-- 3D Background Canvas -->
<canvas id="bg-canvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;"></canvas>

<!-- Original Landing Page Content -->
<div class="row justify-content-center align-items-center p-4" style="position: relative; z-index: 10;">
  <div class="col-lg-4 col-md-6 text-center mt-4">
    <!-- Fine Circle Responsive Image -->
    <div id="container" class="my-2">
      <div id="dummy"></div>
      <div id="element">
        <img src="{{ site.author.image }}" alt="{{ site.title }}" class="circle-image wow animated zoomIn" data-wow-delay=".1s">
      </div>
    </div>
    <p class="text-muted wow animated slideInUp" data-wow-delay=".15s">{{ site.description }}</p>
  </div>
</div>

<!-- 3D Background Script -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// Scene setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({
  canvas: document.querySelector('#bg-canvas'),
  alpha: true,
  antialias: true
});

renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
camera.position.setZ(30);

// Skills/tags to float around
const skillTexts = [
  'C++', 'UnrealEngine', 'AI', 'Network', 'Physics',
  'Jolt', 'ECS', 'Gameplay', 'Blueprints', 'Plugins'
];

const skillMeshes = [];

// Create 3D text geometry for "D" and "K"
const loader = new THREE.FontLoader();
loader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', function(font) {
  
  // Create "D" letter - MORE TO THE LEFT
  const geometryD = new THREE.TextGeometry('D', {
    font: font,
    size: 10,
    height: 2,
    curveSegments: 12,
    bevelEnabled: true,
    bevelThickness: 0.5,
    bevelSize: 0.3,
    bevelOffset: 0,
    bevelSegments: 5
  });
  
  const materialD = new THREE.MeshStandardMaterial({ 
    color: 0x0077ff,
    metalness: 0.6,
    roughness: 0.4,
    emissive: 0x001a33,
    emissiveIntensity: 0.3
  });
  const letterD = new THREE.Mesh(geometryD, materialD);
  letterD.position.set(-25, 0, 0); // Moved further left
  scene.add(letterD);
  
  // Create "K" letter - MORE TO THE RIGHT
  const geometryK = new THREE.TextGeometry('K', {
    font: font,
    size: 10,
    height: 2,
    curveSegments: 12,
    bevelEnabled: true,
    bevelThickness: 0.5,
    bevelSize: 0.3,
    bevelOffset: 0,
    bevelSegments: 5
  });
  
  const materialK = new THREE.MeshStandardMaterial({ 
    color: 0x0077ff,
    metalness: 0.6,
    roughness: 0.4,
    emissive: 0x001a33,
    emissiveIntensity: 0.3
  });
  const letterK = new THREE.Mesh(geometryK, materialK);
  letterK.position.set(15, 0, 0); // Moved further right
  scene.add(letterK);
  
  // Store references for animation
  window.letterD = letterD;
  window.letterK = letterK;
  
  // Create floating skill text
  skillTexts.forEach((skill, index) => {
    const skillGeometry = new THREE.TextGeometry(skill, {
      font: font,
      size: 1.5,
      height: 0.3,
      curveSegments: 8,
      bevelEnabled: true,
      bevelThickness: 0.1,
      bevelSize: 0.05,
      bevelOffset: 0,
      bevelSegments: 3
    });
    
    const skillMaterial = new THREE.MeshStandardMaterial({
      color: 0x88ccff,
      metalness: 0.3,
      roughness: 0.7,
      emissive: 0x003366,
      emissiveIntensity: 0.2
    });
    
    const skillMesh = new THREE.Mesh(skillGeometry, skillMaterial);
    
    // Random positions around the scene
    const angle = (index / skillTexts.length) * Math.PI * 2;
    const radius = 35 + Math.random() * 15;
    skillMesh.position.x = Math.cos(angle) * radius;
    skillMesh.position.y = (Math.random() - 0.5) * 30;
    skillMesh.position.z = -20 + Math.random() * -30;
    
    // Random rotation
    skillMesh.rotation.x = Math.random() * Math.PI;
    skillMesh.rotation.y = Math.random() * Math.PI;
    
    // Store animation data
    skillMesh.userData = {
      orbitSpeed: 0.0002 + Math.random() * 0.0003,
      orbitRadius: radius,
      orbitAngle: angle,
      floatSpeed: 0.001 + Math.random() * 0.002,
      floatPhase: Math.random() * Math.PI * 2
    };
    
    scene.add(skillMesh);
    skillMeshes.push(skillMesh);
  });
});

// Enhanced Lighting
const pointLight = new THREE.PointLight(0xffffff, 1.2);
pointLight.position.set(20, 20, 20);
scene.add(pointLight);

const pointLight2 = new THREE.PointLight(0x4488ff, 0.8);
pointLight2.position.set(-20, -20, 20);
scene.add(pointLight2);

const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);

// Add colorful background particles
function addStar() {
  const geometry = new THREE.SphereGeometry(0.15, 24, 24);
  const colors = [0xffffff, 0x4488ff, 0x88ccff];
  const randomColor = colors[Math.floor(Math.random() * colors.length)];
  const material = new THREE.MeshStandardMaterial({ color: randomColor });
  const star = new THREE.Mesh(geometry, material);
  
  const [x, y, z] = Array(3).fill().map(() => THREE.MathUtils.randFloatSpread(100));
  star.position.set(x, y, z);
  scene.add(star);
  
  star.userData.pulseSpeed = Math.random() * 0.02 + 0.01;
  star.userData.pulsePhase = Math.random() * Math.PI * 2;
  return star;
}

const stars = Array(200).fill().map(addStar);

// Mouse movement tracking - REVERSED horizontal
let mouseX = 0;
let mouseY = 0;
let targetRotationX = 0;
let targetRotationY = 0;

document.addEventListener('mousemove', (event) => {
  mouseX = (event.clientX / window.innerWidth) * 2 - 1;
  mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
  
  // FLIPPED: Added minus sign to reverse horizontal
  targetRotationY = -mouseX * 0.5;
  targetRotationX = mouseY * 0.3;
});

// Animation loop
let time = 0;
function animate() {
  requestAnimationFrame(animate);
  time += 0.01;
  
  // Smooth camera rotation based on mouse
  camera.rotation.y += (targetRotationY - camera.rotation.y) * 0.05;
  camera.rotation.x += (targetRotationX - camera.rotation.x) * 0.05;
  
  // Rotate letters slightly with a wave motion
  if (window.letterD) {
    window.letterD.rotation.y += 0.001;
    window.letterD.rotation.x = Math.sin(time * 0.5) * 0.1;
  }
  if (window.letterK) {
    window.letterK.rotation.y -= 0.001;
    window.letterK.rotation.x = Math.cos(time * 0.5) * 0.1;
  }
  
  // Animate floating skills
  skillMeshes.forEach((skill) => {
    // Orbit around center
    skill.userData.orbitAngle += skill.userData.orbitSpeed;
    skill.position.x = Math.cos(skill.userData.orbitAngle) * skill.userData.orbitRadius;
    skill.position.z = -20 + Math.sin(skill.userData.orbitAngle) * skill.userData.orbitRadius * 0.5;
    
    // Float up and down
    skill.position.y += Math.sin(time * skill.userData.floatSpeed + skill.userData.floatPhase) * 0.02;
    
    // Slow rotation
    skill.rotation.y += 0.002;
  });
  
  // Pulsing stars effect
  stars.forEach((star) => {
    const scale = 1 + Math.sin(time * star.userData.pulseSpeed + star.userData.pulsePhase) * 0.3;
    star.scale.set(scale, scale, scale);
  });
  
  renderer.render(scene, camera);
}

animate();

// Handle window resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

<style>
#bg-canvas {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: -1;
}
</style>
